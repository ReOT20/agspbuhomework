#include <iostream>
#include <cmath>


long reverse(long n, long len) {
	long lim = pow(10, len - 1);
	long i = 0;
	long res = 0;
	while (i < len) {
		res += n % 10 * lim;
		n /= 10;
		lim /= 10;
		i += 1;
	}
	return res;
}


int main() {
	long n;
	std::cin >> n;
	long i = pow(10, n - n / 2 - 1);
	long len = n - n / 2;
	long j;
	int check;
	while (i < pow(10, n - n / 2)) {
		j = 0;
		while (j < n - n / 2 - len) {
			std::cout << 0;
			j++;
		}
		if (i != 0 and n != 1) {
			if (n % 2 == 1) std::cout << i / 10;
			else std::cout << i;
		}
		if (i % 10 == 0) std::cout << 0;
		if (i % 100 == 0) std::cout << 0;
		std::cout << reverse(i, len);
		j = 0;
		while (j < n - n / 2 - len) {
			std::cout << 0;
			j++;
		}
		std::cout << "\n";
		i++;
	}
	return 0;
}

/*Напишите программу, находящую натуральные корни уравнения
2020X + 2021Y=78487894 эффективным перебором.*/

/*Перебор эффективный т.к. сначала мы находим первую пару корней по значению Y,
у которого коэфицент больше чем у X, а значит и возможных значений меньше.
При этом переборе мы используем в шаг 10 и последняя цифра у Y 4 т.к. 
это единственный способ при данных значениях коэфициэнта у X и Y получить 4 на конце 78487894.
Максимальное значение Y берём 78487894/2021 углённое вниз к последней цифре 4.
После этого мы запускаем цикл в 19 итераций просто изменяя X и Y на фиксированный коэфицент.*/
