#include <iostream>

int main() {
	int y = 38834;
	bool check = true;
	int x;
	while (check) {
		if (((78487894 - 2021 * y) % 2020) == 0) {
			x = (78487894 - 2021 * y) / 2020;
			check = false;
		}
		y -= 10;
	}
	y += 10;
	while (y > 0) {
		std::cout << x << "\t" << y << "\n";
		y -= 2020;
		x += 2021;
		std::cout << x * 2020 + y * 2021 << "\n";
	}
	return 0;
}

/*Напишите программу, находящую натуральные корни уравнения
2020X + 2021Y = 78487894 эффективным перебором.*/

/*Перебор эффективен т.к. количество итераций перебора выбрано 
по такому принципу: т.к. около Y коэфициэнт больше, то 78487894 (в дальнейшем n) делим на него 
и определяем Y в пределах от единицы до n / 2021. Далее заметим, что разряд единиц у коэфициэнта X
равен 0,а у коэфициэнта Y 1, то единственный способ получить 4 у n это, чтобы в разряде единиц у Y
было 4, а значит перебираем Y по убыванию с шагом 10 предварительно округлив к 4 в нижнюю сторону верхний предел.
Того 3883 итерации цикла. Значение X получаем из разности Y * 2021 и n делёной на 2020*/